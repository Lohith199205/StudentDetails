{"ast":null,"code":"\"use strict\";\n\nvar redux_1 = require('redux');\nvar Observable_1 = require('rxjs/Observable');\nvar BehaviorSubject_1 = require('rxjs/BehaviorSubject');\nrequire('rxjs/add/operator/map');\nrequire('rxjs/add/operator/filter');\nrequire('rxjs/add/observable/from');\nrequire('rxjs/add/operator/distinctUntilChanged');\nrequire('rxjs/add/operator/switchMap');\nvar type_checks_1 = require('../utils/type-checks');\nvar omit_1 = require('../utils/omit');\nvar invariant_1 = require('../utils/invariant');\nvar get_in_1 = require('../utils/get-in');\nvar VALID_SELECTORS = ['string', 'string[]', 'number', 'symbol', 'function'];\nvar ERROR_MESSAGE = \"Expected selector to be one of:\\n    \" + VALID_SELECTORS.join(',') + \". Instead recieved %s\";\nvar checkSelector = function (s) {\n  return VALID_SELECTORS.indexOf(typeof s, 0) >= 0 || Array.isArray(s);\n};\nvar NgRedux = function () {\n  /**\n   * Creates an instance of NgRedux.\n   */\n  function NgRedux(ngZone) {\n    var _this = this;\n    this.ngZone = ngZone;\n    this._store = null;\n    this._store$ = null;\n    /**\n     * Get the current state of the application\n     * @returns {RootState} the application state\n     */\n    this.getState = function () {\n      return _this._store.getState();\n    };\n    /**\n     * Subscribe to the Redux store changes\n     *\n     * @param {() => void} listener callback to invoke when the state is updated\n     * @returns a function to unsubscribe\n     */\n    this.subscribe = function (listener) {\n      return _this._store.subscribe(listener);\n    };\n    /**\n    * Replaces the reducer currently used by the store to calculate the state.\n    *\n    * You might need this if your app implements code splitting and you want to\n    * load some of the reducers dynamically. You might also need this if you\n    * implement a hot reloading mechanism for Redux.\n    *\n    * @param nextReducer The reducer for the store to use instead.\n    */\n    this.replaceReducer = function (nextReducer) {\n      return _this._store.replaceReducer(nextReducer);\n    };\n    /**\n     * Dispatch an action to Redux\n     */\n    this.dispatch = function (action) {\n      invariant_1.invariant(!!_this._store, 'Dispatch failed: did you forget to configure your store? ' + 'https://github.com/angular-redux/ng2-redux/blob/master/' + 'README.md#quick-start');\n      // Some apps dispatch actions from outside the angular zone; e.g. as\n      // part of a 3rd-party callback, etc. When this happens, we need to\n      // execute the dispatch in-zone or Angular2's UI won't update.\n      return _this.ngZone.run(function () {\n        return _this._store.dispatch(action);\n      });\n    };\n    NgRedux.instance = this;\n    this._store$ = new BehaviorSubject_1.BehaviorSubject(null).filter(function (n) {\n      return n !== null;\n    }).switchMap(function (n) {\n      return Observable_1.Observable.from(n);\n    });\n  }\n  /**\n   * configures a Redux store and allows NgRedux to observe and dispatch\n   * to it.\n   *\n   * This should only be called once for the lifetime of your app, for\n   * example in the constructor of your root component.\n   *\n   * @param {Redux.Reducer<RootState>} reducer Your app's root reducer\n   * @param {RootState} initState Your app's initial state\n   * @param {Redux.Middleware[]} middleware Optional Redux middlewares\n   * @param {Redux.StoreEnhancer<RootState>[]} Optional Redux store enhancers\n   */\n  NgRedux.prototype.configureStore = function (reducer, initState, middleware, enhancers) {\n    if (middleware === void 0) {\n      middleware = [];\n    }\n    if (enhancers === void 0) {\n      enhancers = [];\n    }\n    invariant_1.invariant(!this._store, 'Store already configured!');\n    // Workaround for Redux issue #1935 - remove once Redux 3.6.0 is\n    // released.\n    var reTypedCompose = redux_1.compose;\n    var finalCreateStore = reTypedCompose.apply(void 0, [redux_1.applyMiddleware.apply(void 0, middleware)].concat(enhancers))(redux_1.createStore);\n    var store = finalCreateStore(reducer, initState);\n    this.setStore(store);\n  };\n  /**\n   * Accepts a Redux store, then sets it in NgRedux and\n   * allows NgRedux to observe and dispatch to it.\n   *\n   * This should only be called once for the lifetime of your app, for\n   * example in the constructor of your root component. If configureStore\n   * has been used this cannot be used.\n   *\n   * @param {Redux.Store} store Your app's store\n   */\n  NgRedux.prototype.provideStore = function (store) {\n    invariant_1.invariant(!this._store, 'Store already configured!');\n    this.setStore(store);\n  };\n  ;\n  /**\n   * Select a slice of state to expose as an observable.\n   *\n   * @template S\n   * @param { PropertySelector |\n   *  PathSelector |\n   *  FunctionSelector<RootState, S>}\n   * selector key or function to select a part of the state\n   * @param { Comparator } [comparer] Optional\n   * comparison function called to test if an item is distinct\n   * from the previous item in the source.\n   *\n   * @returns {Observable<S>} an Observable that emits items from the\n   * source Observable with distinct values.\n   */\n  NgRedux.prototype.select = function (selector, comparator) {\n    if (!selector) {\n      return this._store$.distinctUntilChanged(comparator);\n    }\n    invariant_1.invariant(checkSelector(selector), ERROR_MESSAGE, selector);\n    var result;\n    var changedStore = this._store$.distinctUntilChanged();\n    if (typeof selector === 'string' || typeof selector === 'number' || typeof selector === 'symbol') {\n      result = changedStore.map(function (state) {\n        return state[selector];\n      });\n    } else if (Array.isArray(selector)) {\n      result = changedStore.map(function (state) {\n        return get_in_1.getIn(state, selector);\n      });\n    } else {\n      result = changedStore.map(selector);\n    }\n    return result.distinctUntilChanged(comparator);\n  };\n  NgRedux.prototype.getStateSlice = function (state, mapStateToScope) {\n    var slice = mapStateToScope(state);\n    invariant_1.invariant(type_checks_1.isPlainObject(slice), '`mapStateToScope` must return an object. Instead received %s.', slice);\n    return slice;\n  };\n  NgRedux.prototype.setStore = function (store) {\n    this._store = store;\n    this._store$.next(store);\n    this._defaultMapStateToTarget = function () {\n      return {};\n    };\n    this._defaultMapDispatchToTarget = function (dispatch) {\n      return {\n        dispatch: dispatch\n      };\n    };\n    var cleanedStore = omit_1.omit(store, ['dispatch', 'getState', 'subscribe', 'replaceReducer']);\n    Object.assign(this, cleanedStore);\n  };\n  return NgRedux;\n}();\nexports.NgRedux = NgRedux;\n;\n//# sourceMappingURL=ng-redux.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}